#include <stdio.h> /* Δήλωση βιβλιοθηκών που χρησιμοποιούνται στο πρόγραμμα. */
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <ctype.h>
#include <signal.h>

#define UNIXSTR_PATH "/tmp/unix.str" /* Καθορισμός του path που θα χρησιμοποιηθεί για την επικοινωνία μεταξύ server-client. */
#define SUCCESS 0 /* Προσδιορισμός σταθερής μεταβλητής για μερική διευκόλυνση ανάγνωσης του προγράμματος. */
#define SHM_KEY IPC_PRIVATE /* Προσδιορισμός του αριθμητικού κλειδιού για τη δημιουργία της κοινής μνήμης. */

int connection(); /* Δήλωση καθορισμένων συναρτήσεων που χρησιμοποιούνται για τις διάφορες επιθυμητές λειτουργίες. */
void kill_client();
void new_account();
void new_reservation();
void account_info();
void deposit_money();
void search_account();
void new_parking();
void view_driver_last_reservation();
void view_last_reservation();
void goodbye_message();

int sockdes; /* Δήλωση μεταβλητής file descriptor για την αποθήκευση της τιμής που προσδιορίζει το socket επικοινωνίας. */
char buffer[256]; /* Δήλωση προσωρινής μεταβλητής που χρειάζεται κατά την εκτέλεση της scanf ώστε να δέχεται ένα string οποιουδήποτε ονόματος (οδηγού, ιδιοκτήτη, κ.λ.π.), ενώ στην συνέχεια, ανάλογα με την περίπτωση, γίνεται έλεγχος και κρατείται μόνο το καταλληλο μήκος χαρακτήρων. */
struct sockaddr sock_add; /* Δήλωση μεταβλητών για την αποθήκευση των διευθύνσεων επικοινωνίας. */
int num_parkings; /* Δήλωση μεταβλητής για την αποθήκευση του συνολικού αριθμού parking. */

struct parking{ /* Δήλωση του struct για τα parking. */
	char parking_name[15]; /* Δήλωση μεταβλητής για την αποθήκευση του ονόματος του parking. */
	char description[80]; /* Δήλωση μεταβλητής για την αποθήκευση της περιγραφής του parking. */
	float price; /* Δήλωση μεταβλητής για την αποθήκευση της τιμής του parking. */
	char last[40]; /* Δήλωση μεταβλητής για την αποθήκευση της οδηγού που έκανε την τελευταία κράτηση. */
	int driver_number; /* Δήλωση μεταβλητής για την αποθήκευση του αριθμού των οδηγών που έχουν κάνει κράτηση στο parking. */
	int free; /* Δήλωση μεταβλητής που δείχνει τον αριθμό των ελεύθερων θέσεων στο parking. */
} parking[200];	/* Δήλωση ενός πίνακα από parking με 200 κελιά. */

struct client_account{ /* Δήλωση του struct για τις οδηγούς. */
	char name[40]; /* Δήλωση μεταβλητής για την αποθήκευση του ονόματος της οδηγού. */
	float money; /* Δήλωση μεταβλητής για την αποθήκευση των χρημάτων που διαθέτει η οδηγός. */
	char reservations[15]; /* Δήλωση μεταβλητής για την αποθήκευση του ονόματος parking στο οποίο έγινε από την οδηγό η τελευταία κράτηση. */
	int parked; /* Δήλωση μεταβλητής που χρησιμοποιείται για να διευκρινιστεί αν η οδηγός έχει κάνει ήδη κράτηση ή όχι. */
	int counter_park; /* Δήλωση μεταβλητής για την αποθήκευση του αριθμού των υπάρχοντων parking, ώστε να πραγματοποιείται η εκτύπωση τους πριν μια κράτηση και να διευκολύνεται η επιλογή μεταξύ αυτών. */
} client[1000]; /* Δήλωση ενός πίνακα από client_account με 1000 κελιά. */

int main(){ /* Κύριο πρόγραμμα. */
	int choice, choice1, choice2; /* Δήλωση μεταβλητών για τις ανάλογες δομές επιλογής switch στα επιμέρους menu. */
	int no_parkings=0; /* Δήλωση μεταβλητής που δείχνει την ύπαρξη parking όταν είναι 1. */
	int no_drivers=0; /* Δήλωση μεταβλητής που δείχνει την ύπαρξη οδηγών όταν είναι 1. */
	
	signal(SIGINT, kill_client); /* Ρύθμιση και προσδιορισμός του signal handler για το κλείσιμο της διεργασίας με τον συνδυασμό CTRL+C. */

	/* Εκτύπωση εισαγωγικής εικόνας και κειμένου καλωσορίσματος. */
	printf( "                                    _________\n"
		"                             _.--\"\"'-----,   `\"--.._\n"
		"                          .-''   _/_      ; .'\"----,`-,\n"
		"                        .'      :___:     ; :      ;;`.`.\n"
		"                       .      _.- _.-    .' :      ::  `..\n"
		"                    __;..----------------' :: ___  ::   ;;\n"
		"               .--\"\". '           ___.....`:=(___)-' :--'`.\n"
		"             .'   .'         .--''__       :       ==:    ;\n"
		"         .--/    /        .'.''     ``-,   :         :   '`-.\n"
		"      .\"', :    /       .'-`\\\\       .--.\\ :         :  ,   _\\\n"
		"     ;   ; |   ;       /:'  ;;      /__  \\\\:         :  :  /_\\\\\n"
		"     |\\_/  |   |      / \\__//      /\"--\\\\ \\:         :  : ;|`\\|    \n"	
		"     : \"  /\\__/\\____//   \"\"\"      /     \\\\ :         :  : :|'||\n"	
		"    \"------....______         ].'|      // |--\"\"\"'__...-'`\\ \\//\n"
		"      `| CEID OS |__;_...--'\": :  \\    //  |---\"\"\"      \\__\\_/\n"
		"        \"\"\"\"\"\"\"\"\"'            \\ \\  \\_.//  /\n"
		"          `---'                \\ \\_     _'\n"
		"                                `--`---'\n"
		"--------------------------------------------------------------------------\n"
		"\t\t\t   CEID OS PARKING SERVICE\n"
		"--------------------------------------------------------------------------\n"
		"\t\t (you can always exit by pressing CTRL+C)\n");
	
	while(1){ /* Κύριος βρόχος εμφάνισης του γενικού interface. */
		printf( "--------------------------------------------------------------------------\n" /*Εκτύπωση κύριου menu επιλογής. */
			"--------------------------------------------------------------------------\n"
			"\t\t\t\t× MAIN MENU ×\n"
			"--------------------------------------------------------------------------\n"
			"\t\t\t   1. Owner services.\n"
			"\t\t\t   2. Driver services.\n"
			"\t\t\t   0. Exit.\n"
			"--------------------------------------------------------------------------\n"
			"Your selection: ");

		scanf("%d", &choice); /* Ανάγνωση επιλογής του client. */

		switch(choice){ /* Δομή επιλογής switch για τον προσδιορισμό του τύπου του client, είτε ιδιοκτήτη είτε οδηγού. */
			case 1:	/* Περίπτωση επιλογής υπηρεσιών για ιδιοκτήτες. */
				printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση menu επιλογής για ιδιοκτήτες. */
					"--------------------------------------------------------------------------\n"
					"\t\t\t\t× OWNER MENU ×\n"
					"--------------------------------------------------------------------------\n"
					"\t\t\t   1. Create new parking.\n"
					"\t\t\t   2. View last reservation.\n"
					"\t\t\t   3. Go back to the main menu.\n"
					"\t\t\t   0. Exit.\n"
					"--------------------------------------------------------------------------\n"
					"Your selection: ");

				scanf("%d", &choice1); /* Ανάγνωση επιλογής του ιδιοκτήτη. */

				switch(choice1){ /* Δομή επιλογής switch για τον προσδιορισμό της λειτουργίας που επιθυμεί ένας ιδιοκτήτης. */
					case 1: /* Περίπτωση δημιουργίας νέου parking. */
						new_parking(); /* Κλήση συνάρτησης για τη δημιουργία νέου parking. */
						no_parkings=1; /* Αλλαγή τιμής της μεταβλητής no_parkings ώστε να δείχνει ότι πλέον υπάρχουν parking. */
						break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice1. */
					case 2: /* Περίπτωση εμφάνισης τελευταίας καταχώρησης στο parking. */
						if(no_parkings==0) /* Έλεγχος για το αν υπάρχουν parking. */
							printf( "--------------------------------------------------------------------------\n"
								"Sorry, no parking has been created yet.\n"); /* Εκτύπωση μηνύματος για τη μη ύπαρξη parking. */
						else /* Εάν πληρούνται όλες οι συνθήκες, τότε καλεί την συνάρτηση για την εμφάνιση της τελευταίας καταχώρησης στο επιλεγμένο parking. */
							view_last_reservation(); /* Κλήση συνάρτησης για την εμφάνιση της τελευταίας καταχώρησης στο επιλεγμένο parking. */
						break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice1. */
					case 3: /* Περίπτωση επιστροφής στο αρχικό menu. */
						break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice1. */
					case 0: /* Περίπτωση εξόδου από το πρόγραμμα. */
						goodbye_message(); /* Κλήση συνάρτησης για την εκτύπωση του αποχαιρετηστήριου μηνύματος. */
						exit(1); /* Κλείσιμο της διεργασίας του client. */
					// ΧΧΧ Θα βάλουμε default;
				}
				break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice. */
			case 2: /* Περίπτωση επιλογής υπηρεσιών για οδηγούς. */
				printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση menu επιλογής για οδηγούς. */
					"--------------------------------------------------------------------------\n"
					"\t\t\t\t× DRIVER MENU ×\n"
					"--------------------------------------------------------------------------\n"
					"\t\t\t   1. Create a new account.\n"
					"\t\t\t   2. Make a new reservation.\n"
					"\t\t\t   3. View a driver's account information.\n"
					"\t\t\t   4. Deposit money to an account.\n"
					"\t\t\t   5. View a driver's last reservation.\n"
					"\t\t\t   6. Go back to the main menu.\n"
					"\t\t\t   0. Exit.\n"
					"--------------------------------------------------------------------------\n"
					"Your selection: ");

				scanf("%d", &choice2); /* Ανάγνωση επιλογής της οδηγού. */

				switch(choice2){ /* Δομή επιλογής switch για τον προσδιορισμό της λειτουργίας που επιθυμεί μια οδηγός. */
					case 1: /* Περίπτωση δημιουργίας νέου λογαριασμού οδηγού. */
						new_account(); /* Κλήση συνάρτησης για τη δημιουργία νέου λογαριασμού. */
						no_drivers=1; /* Αλλαγή τιμής της μεταβλητής no_drivers ώστε να δείχνει ότι πλέον υπάρχουν οδηγοί. */
			                        break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice2. */
					case 2: /* Περίπτωση πραγματοποίησης νέας κράτησης σε parking. */
						if(no_drivers==0) /* Έλεγχος για το αν υπάρχουν οδηγοί. */
							printf("Sorry, no driver account has been created yet.\n"); /* Εκτύπωση μηνύματος για τη μη ύπαρξη οδηγών. */
						else if(no_parkings==0)	/* Έλεγχος για το αν υπάρχουν parking. */					
							printf("Sorry, no parking has been created yet.\n"); /* Εκτύπωση μηνύματος για τη μη ύπαρξη parking. */
						else /* Εάν πληρούνται όλες οι συνθήκες, τότε καλεί την συνάρτηση για την πραγματοποίηση νέας κράτησης σε parking. */
							new_reservation(); /* Κλήση συνάρτησης για την πραγματοποίηση νέας κράτησης σε parking. */
						break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice2. */
					case 3: /* Περίπτωση εμφάνισης πληροφοριών ενός λογαριασμού. */
						if(no_drivers==0) /* Έλεγχος για το αν υπάρχουν οδηγοί. */
							printf("Sorry, no driver account has been created yet.\n"); /* Εκτύπωση μηνύματος για τη μη ύπαρξη οδηγών. */
						else /* Εάν πληρούνται όλες οι συνθήκες, τότε καλεί την συνάρτηση για την εμφάνιση των δεδομένων μιας οδηγού. */
							account_info(); /* Κλήση συνάρτησης για την εμφάνιση των δεδομένων μιας οδηγού. */
						break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice2. */
					case 4: /* Περίπτωση κατάθεσης χρημάτων σε υπάρχοντα λογαριασμό. */
						if(no_drivers==0) /* Έλεγχος για το αν υπάρχουν οδηγοί. */
							printf("Sorry, no driver account has been created yet.\n"); /* Εκτύπωση μηνύματος για τη μη ύπαρξη οδηγών. */
						else /* Εάν πληρούνται όλες οι συνθήκες, τότε καλεί την συνάρτηση για την πραγματοποίηση κατάθεσης χρημάτων σε ένα λογαριασμό μιας οδηγού. */
							deposit_money(); /* Κλήση συνάρτησης για την πραγματοποίηση κατάθεσης χρημάτων σε ένα λογαριασμό μιας οδηγού. */
						break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice2. */
					case 5: /* Περίπτωση εμφάνισης της τελευταίας κράτησης μιας οδηγού. */
						if(no_drivers==0) /* Έλεγχος για το αν υπάρχουν οδηγοί. */
							printf("Sorry, no driver account has been created yet.\n"); /* Εκτύπωση μηνύματος για τη μη ύπαρξη οδηγών. */
						else if(no_parkings==0) /* Έλεγχος για το αν υπάρχουν parking. */					
							printf("Sorry, no parking has been created yet.\n"); /* Εκτύπωση μηνύματος για τη μη ύπαρξη parking. */
						else /* Εάν πληρούνται όλες οι συνθήκες, τότε καλεί την συνάρτηση για την εμφάνιση της τελευταίας κράτησης της οδηγού. */					
							view_driver_last_reservation(); /* Κλήση συνάρτησης για την εμφάνιση του ονόματος στο οποίο έκανε την τελευταία κράτησή της η οδηγός. */
						break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice2. */
					case 6: /* Περίπτωση επιστροφής στο αρχικό menu. */
						break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice2. */
					case 0:	/* Περίπτωση εξόδου από το πρόγραμμα. */
						goodbye_message(); /* Κλήση συνάρτησης για την εκτύπωση του αποχαιρετηστήριου μηνύματος. */
						exit(1); /* Κλείσιμο της διεργασίας του client. */
				}
				break; /* Έξοδος από τη δομή switch για τη μεταβλητή choice. */
			case 0: /* Περίπτωση επιλογής εξόδου από το πρόγραμμα. */
				goodbye_message(); /* Κλήση συνάρτησης για την εκτύπωση του αποχαιρετηστήριου μηνύματος. */
				exit(1); /* Κλείσιμο της διεργασίας του client. */
		}
	}
}

void new_account(){ /* Συνάρτηση δημιουργίας νέου λογαριασμού οδηγού. */
	const int operation=1; /* Δήλωση σταθερής μεταβλητής για τον προσδιορισμό σταθερού αριθμού αντιστοίχισης σε μια λειτουργία και διευκόλυνση διαχωρισμού και επιλογής στον server. */
	int exists; /* Δήλωση μεταβλητής για τον έλεγχο ύπαρξης ενός λογαριασμού. */
	struct client_account newdriver; /* Δήλωση τοπικής μεταβλητής client_account για τη διευκόλυνση αποθήκευσης δεδομένων και επικοινωνίας. */

	if((sockdes=socket(AF_UNIX, SOCK_STREAM, 0))<0){ /* Δημιουργία socket επικοινωνίας μεταξύ client-server και έλεγχος για περίπτωση εμφάνισης σφάλματος. */
		perror("Client error: socket."); /* Εκτύπωση μηνύματος σφάλματος. */
		exit(1); /* Κλείσιμο της διεργασίας του client. */
	}

	if(connection()){ /* Κλήση συνάρτησης connection() για την πραγματοποίηση σύνδεσης με τον server και μερικός έλεγχος επιτυχίας. */
		write(sockdes, &operation, sizeof(operation)); /* Αποστολή στον server της τιμής της μεταβλητής που προσδιορίζει την επιλεγμένη λειτουργία, εν προκειμένω τη δημιουργία νέου λογαριασμού οδηγού. */
		
		while(1){ /* Βρόχος εισαγωγής του ονόματος του λογαριασμού, έως ότου δοθούν επιτρεπτά στοιχεία. */
			printf("\tPlease enter your name: "); /* Εκτύπωση προτροπής για την εισαγωγή του ονόματος της οδηγού. */
			scanf(" %[^\n]", buffer); /* Ανάγνωση του ονόματος της οδηγού. */
			strncpy(newdriver.name, buffer, 41); /* Αντιγραφή τουλάχιστον των 41 πρώτων χαρακτήρων από την προσωρινή μεταβλητή buffer στην newdriver.name. */

			if(strlen(buffer)>40) /* Eκχώρηση ενός null character στην 40η θέση σε περίπτωση που η είσοδος ήταν μεγαλυτέρου μεγέθους. */
				newdriver.name[40]='\0';

			write(sockdes, newdriver.name, sizeof(newdriver.name)); /* Αποστολή του ονόματος στον server. */
			read(sockdes, &exists, sizeof(exists)); /* Ανάγνωση από τον server για το αν υπάρχει το σταλθέν όνομα. */

			if(exists==SUCCESS) /* Έλεγχος της exists για την ύπαρξη ή μη του ονόματος. */
				printf( "This name already exists, please try a different one.\n" /* Εκτύπωση μηνύματος για την ύπαρξη του δοθέντος ονόματος και προτροπή για εισαγωγή διαφορετικού. */
					"--------------------------------------------------------------------------\n");
			else /* Εάν δεν υπάρχει το όνομα, συνεχίζει παρακάτω. */
				break; /* Έξοδος από το βρόχο εισαγωγής ονόματος. */
		}

		printf("\tPlease enter your money (in euros): "); /* Εκτύπωση προτροπής για την εισαγωγή των χρημάτων της οδηγού. */
		scanf("%f", &newdriver.money); /* Ανάγνωση των χρημάτων του λογαριασμού. */

		while(newdriver.money<=0.0){ /* Βρόχος ελέγχου για την ορθότητα του εισαχθέντος ποσού χρημάτων. */
			printf("Error: wrong amount given.\n" /* Εκτύπωση σφάλματος κατά την εισαγωγή του ποσού του λογαριασμού. */
			       "\tPlease reenter the desired amount: "); /* Εκτύπωση προτροπής για την επανεισαγωγή των χρημάτων της οδηγού. */
			scanf("%f", &newdriver.money); /* Ανάγνωση των χρημάτων του λογαριασμού. */
		}

		if(write(sockdes, &newdriver, sizeof(newdriver))<0){ /* Αποστολή των στοιχείων του λογαριασμού στον server και μερικός έλεγχος για την επιτυχή αποστολή τους. */
			printf( "Error: could not create a new account.\n" /* Εκτύπωση μηνύματος αποτυχίας αποστολής και δημιουργίας καινούργιου λογαριασμού. */
				"Your connection was terminated.\n");
		}
		else{ /* Επιτυχής δημιουργία νέου λογαριασμού. */
			printf(	"--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος επιτυχούς νέας καταχώρησης λογαριασμού. */
				"%s's driver account with %.2f € ", newdriver.name , newdriver.money);
			printf( "was successfully created.\n"); 

			if(read(sockdes, &newdriver, sizeof(newdriver))<0){ /* Ανάγνωση των στοιχείων του δημιουργηθέντος λογαριασμού από τον server για επιβεβαίωση. */
				perror("Client error: read."); /* Εκτύπωση μηνύματος σφάλματος. */
				exit(1); /* Κλείσιμο της διεργασίας του client. */
			}
		}
	}
	close(sockdes); /* Κλείσιμο του socket επικοινωνίας. */
}

void new_reservation(){ /* Συνάρτηση για την πραγματοποίηση νέας κράτησης parking. */
	const int operation=2; /* Δήλωση σταθερής μεταβλητής για τον προσδιορισμό σταθερού αριθμού αντιστοίχισης σε μια λειτουργία και διευκόλυνση διαχωρισμού και επιλογής στον server. */
	struct client_account newdriver; /* Δήλωση τοπικής μεταβλητής client_account για τη διευκόλυνση αποθήκευσης δεδομένων και επικοινωνίας. */
	struct parking newparking; /* Δήλωση τοπικής μεταβλητής parking για τη διευκόλυνση αποθήκευσης δεδομένων και επικοινωνίας. */
	int x=0, t=0; /* Δήλωση και αρχικοποίηση μεταβλητών που χρησιμοποιούνται στο βρόχο εκτύπωσης. */
	int exists; /* Δήλωση μεταβλητής για τον έλεγχο ύπαρξης ενός parking. */

	if((sockdes=socket(AF_UNIX, SOCK_STREAM, 0))<0){ /* Δημιουργία socket επικοινωνίας μεταξύ client-server και έλεγχος για περίπτωση εμφάνισης σφάλματος. */
		perror("Client error: socket."); /* Εκτύπωση μηνύματος σφάλματος. */
		exit(1); /* Κλείσιμο της διεργασίας του client. */
	}

	if(connection()){ /* Κλήση συνάρτησης connection() για την πραγματοποίηση σύνδεσης με τον server και μερικός έλεγχος επιτυχίας. */
		write(sockdes, &operation, sizeof(operation)); /* Αποστολή στον server της τιμής της μεταβλητής που προσδιορίζει την επιλεγμένη λειτουργία, εν προκειμένω την πραγματοποίηση νέας κράτησης. */
		search_account(newdriver); /* Κλήση της συνάρτησης search_account() για την αναζήτηση και επιβεβαίωση της ύπαρξης του λογαριασμού της οδηγού, ώστε να μπορεί στη συνέχεια να πραγματοποιήσει μια κράτηση σ' ένα parking. */

		printf(	"--------------------------------------------------------------------------\n" /* Εκτύπωση επικεφαλίδας του ακόλουθου βρόχου με τα διαθέσιμα parking. */
			"\t\t\t× AVAILABLE PARKINGS ×\n"
			"--------------------------------------------------------------------------\n");

		for(x=0; x<=200; x++){ /* Βρόχος εκτύπωσης των διαθέσιμων parking ώστε να διευκολυνθεί η οδηγός στην επιλογή μεταξύ αυτών. */
			read(sockdes, &newparking, sizeof(struct parking)); /* Ανάγνωση των στοιχείων του parking από τον server. */

			if (strlen(newparking.parking_name)>=1){ /* Έλεγχος μήκους του ονόματος ενός parking και κατ' επέκταση της ύπαρξής του, αν αποτελείται από τουλάχιστον ένα χαρακτήρα τότε εκτυπώνεται. */
				t++; /* Αύξηση του μετρητή για την αριθμημένη εκτύπωση των διαθέσιμων parking. */
				printf( "%d) Parking name: %s - Cost: %.2f€ - Available slots: %d \n", /* Εκτύπωση στοιχείων του parking. */
					t, newparking.parking_name , newparking.price, newparking.free);
			}
		}

		printf("--------------------------------------------------------------------------\n");	/* Εκτύπωση διαχωριστικής γραμμής. */
		exists=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή exists για τπν επόμενο έλεγχο ύπαρξης parking. */
		printf("\tPlease enter parking's name: "); /* Εκτύπωση προτροπής για την είσοδο του ονόματος του parking. */
		scanf(" %[^\n]", buffer); /* Ανάγνωση του ονόματος του parking. */
		strncpy(newparking.parking_name, buffer, 16); /* Αντιγραφή τουλάχιστον των 16 πρώτων χαρακτήρων από την προσωρινή μεταβλητή buffer στην newparking.parking_name. */

		if(strlen(buffer)>15) /* Eκχώρηση ενός null character στην 16η θέση σε περίπτωση που η είσοδος ήταν μεγαλυτέρου μεγέθους. */
			newparking.parking_name[15]='\0';
		
		while(exists==-1){ /* Βρόχος ελέγχου για την ύπαρξη του parking. */
			write(sockdes, newparking.parking_name, sizeof(newparking.parking_name)); /* Αποστολή του ονόματος του parking στον server για την πραγματοποίηση ελέγχου. */
			read(sockdes, &exists, sizeof(exists)); /* Ανάγνωση από τον server του αποτελέσματος της παραπάνω αναζήτησης. */

			if(exists==-1){ /* Έλεγχος για την ύπαρξη ή μη του parking. */
				printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος μη ύπαρξης του parking που εισήχθηκε. */
					"This parking doesn't exist, please try again.\n"
					"--------------------------------------------------------------------------\n"
					"\tEnter parking's name: "); /* Εκτύπωση προτροπής για την είσοδο του ονόματος του parking. */
				scanf(" %[^\n]", buffer); /* Ανάγνωση του ονόματος του parking. */
				strncpy(newparking.parking_name, buffer, 16); /* Αντιγραφή τουλάχιστον των 16 πρώτων χαρακτήρων από την προσωρινή μεταβλητή buffer στην newparking.parking_name. */

				if(strlen(buffer)>15) /* Eκχώρηση ενός null character στην 16η θέση σε περίπτωση που η είσοδος ήταν μεγαλυτέρου μεγέθους. */
					newparking.parking_name[15]='\0';
			}
			else{ /* Εάν υπάρχει το parking, τότε προχωρά. */
				read(sockdes, &newparking, sizeof(struct parking)); /* Ανάγνωση από τον server των στοιχείων του parking. */
				read(sockdes, &newdriver, sizeof(struct client_account)); /* Ανάγνωση από τον server των στοιχείων της οδηγού. */

				if(newdriver.money<newparking.price){ /* Έλεγχος για την επάρκεια των χρημάτων της οδηγού ώστε να πραγματοποιήσει κράτηση στο παρόν parking. */
					printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος αν η οδηγός δεν έχει αρκετά χρήματα για την κράτηση. */
						"Sorry, you do not have enough money to park in here.\n");
					break; /* Έξοδος από το βρόχο ελέγχου. */
				}
				else if((newdriver.money>newparking.price)&&(newparking.free<=0)){ /* Μετέπειτα έλεγχος για την ύπαρξη διαθέσιμων θέσεων για κράτηση. */
					printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος αν δεν υπάρχουν κενές θέσεις για κράτηση στο parking. */
						"Sorry, there is not enough space to park in here.\n"); 
					break; /* Έξοδος από το βρόχο ελέγχου. */
				}
				else if(newdriver.parked!=0){ /* Έλεγχος για ήδη πραγματοποιημένη κράτηση της οδηγού. */
					printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος αν η οδηγός έχει κάνει ήδη μια κράτηση σε κάποιο parking. */
						"Sorry, you have already parked somewhere else.\n");
					break; /* Έξοδος από το βρόχο ελέγχου. */
				}		
				else /* Εάν πληρούνται όλες οι συνθήκες, τότε πραγματοποιείται η κράτηση. */	
					printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος για την επιτυχή πραγματοποίηση της κράτησης στο parking. */
						"Thank you for using the %s parking!\n" 
						"There are %d free slots now.\n", 
						newparking.parking_name, newparking.free-1);
			}
		}		
	}
	close(sockdes); /* Κλείσιμο του socket επικοινωνίας. */ 
}

void account_info(){ /* Συνάρτηση εμφάνισης πληροφοριών λογαριασμού μιας οδηγού. */
	const int operation=3; /* Δήλωση σταθερής μεταβλητής για τον προσδιορισμό σταθερού αριθμού αντιστοίχισης σε μια λειτουργία και διευκόλυνση διαχωρισμού και επιλογής στον server. */
 	struct client_account newdriver; /* Δήλωση τοπικής μεταβλητής client_account για τη διευκόλυνση αποθήκευσης δεδομένων και επικοινωνίας. */

	if((sockdes=socket(AF_UNIX, SOCK_STREAM, 0))<0){ /* Δημιουργία socket επικοινωνίας μεταξύ client-server και έλεγχος για περίπτωση εμφάνισης σφάλματος. */
		perror("Client error: socket."); /* Εκτύπωση μηνύματος σφάλματος. */
		exit(1); /* Κλείσιμο της διεργασίας του client. */
	}
	
	if(connection()){ /* Κλήση συνάρτησης connection() για την πραγματοποίηση σύνδεσης με τον server και μερικός έλεγχος επιτυχίας. */
		write(sockdes, &operation, sizeof(operation)); /* Αποστολή στον server της τιμής της μεταβλητής που προσδιορίζει την επιλεγμένη λειτουργία, εν προκειμένω την εμφάνιση των πληροφοριών λογαριασμού μιας οδηγού. */
		search_account(newdriver); /* Κλήση της συνάρτησης search_account() για την αναζήτηση και επιβεβαίωση της ύπαρξης του λογαριασμού της οδηγού. */
	}
}

void deposit_money(){ /* Συνάρτηση για την πραγματοποίηση κατάθεσης χρημάτων σε ένα λογαριασμό μιας οδηγού. */ 
	const int operation=4; /* Δήλωση σταθερής μεταβλητής για τον προσδιορισμό σταθερού αριθμού αντιστοίχισης σε μια λειτουργία και διευκόλυνση διαχωρισμού και επιλογής στον server. */
	struct client_account selected_driver; /* Δήλωση τοπικής μεταβλητής client_account για τη διευκόλυνση αποθήκευσης δεδομένων και επικοινωνίας. */

	if((sockdes=socket(AF_UNIX, SOCK_STREAM, 0))<0){ /* Δημιουργία socket επικοινωνίας μεταξύ client-server και έλεγχος για περίπτωση εμφάνισης σφάλματος. */
		perror("Client error: socket."); /* Εκτύπωση μηνύματος σφάλματος. */
		exit(1); /* Κλείσιμο της διεργασίας του client. */
	}

	if(connection()){ /* Κλήση συνάρτησης connection() για την πραγματοποίηση σύνδεσης με τον server και μερικός έλεγχος επιτυχίας. */
		write(sockdes, &operation, sizeof(operation)); /* Αποστολή στον server της τιμής της μεταβλητής που προσδιορίζει την επιλεγμένη λειτουργία, εν προκειμένω την κατάθεση χρημάτων σε λογαριασμό. */

		while(1){ /* Βρόχος εισαγωγής του ποσού των χρημάτων που επιθυμεί η οδηγός για κατάθεση. */
			search_account(selected_driver); /* Κλήση της συνάρτησης search_account() για την αναζήτηση και επιβεβαίωση της ύπαρξης του λογαριασμού της οδηγού. */
			
			printf("Enter the desired amount: "); /* Εκτύπωση προτροπής για την είσοδο των χρημάτων που επιθυμεί να καταθέσει η οδηγός. */
			scanf("%f", &selected_driver.money); /* Ανάγνωση των χρημάτων της κατάθεσης. */

			while(selected_driver.money<=0){ /* Έλεγχος για το αν η τιμή του ποσού των χρημάτων που εισήχθη είναι αποδεκτή, δηλαδή μη αρνητική. */
				printf("Error: wrong amount given.\n" /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση που το ποσό των χρημάτων που εισήχθη είναι μικρότερο του μηδενός. */
				       "\tPlease reenter the desired amount: "); /* Εκτύπωση προτροπής για την επανεισαγωγή των χρημάτων που επιθυμεί να καταθέσει η οδηγός. */
				scanf("%f", &selected_driver.money); /* Ανάγνωση των χρημάτων της κατάθεσης. */
			}
			break; /* Έξοδος από το βρόχο εισαγωγής των χρημάτων. */
		}
			
		if(write(sockdes, &selected_driver.money, sizeof(selected_driver.money))<0){ /* Αποστολή στον server του ποσού των χρημάτων που θέλει να καταθέσει η οδηγός και μερικός έλεγχος επιτυχίας της αποστολής. */
			printf( "Error: could not add more money.\n" /* Εκτύπωση μηνύματος σφάλματος κατά την κατάθεση. */
				"Your connection was terminated.\n");
		}

		read(sockdes, &selected_driver, sizeof(struct client_account)); /* Ανάγνωση από τον server των στοιχείων της επιλεγμένης οδηγού για επιβεβαίωση κατάθεσης. */

		printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση των στοιχείων της οδηγού που λήφθηκαν παραπάνω. */
			"\t\t\t× DRIVER'S INFO ×\n"
			"--------------------------------------------------------------------------\n"
			"Name: %s\n"
			"Money: %.2lf €\n",
			selected_driver.name, selected_driver.money);
	}
	close(sockdes); /* Κλείσιμο του socket επικοινωνίας. */ 
}

void new_parking(){ /* Συνάρτηση για τη δημιουργία νέου parking. */
	const int operation=5; /* Δήλωση σταθερής μεταβλητής για τον προσδιορισμό σταθερού αριθμού αντιστοίχισης σε μια λειτουργία και διευκόλυνση διαχωρισμού και επιλογής στον server. */
	int exists; /* Δήλωση μεταβλητής για τον έλεγχο ύπαρξης ενός parking. */
	struct parking newparking; /* Δήλωση τοπικής μεταβλητής parking για τη διευκόλυνση αποθήκευσης δεδομένων και επικοινωνίας. */
	
	if((sockdes=socket(AF_UNIX, SOCK_STREAM, 0))<0){ /* Δημιουργία socket επικοινωνίας μεταξύ client-server και έλεγχος για περίπτωση εμφάνισης σφάλματος. */
		perror("Client error: socket."); /* Εκτύπωση μηνύματος σφάλματος. */
		exit(1); /* Κλείσιμο της διεργασίας του client. */
	}

	if(connection()){ /* Κλήση συνάρτησης connection() για την πραγματοποίηση σύνδεσης με τον server και μερικός έλεγχος επιτυχίας. */
		write(sockdes, &operation, sizeof(operation)); /* Αποστολή στον server της τιμής της μεταβλητής που προσδιορίζει την επιλεγμένη λειτουργία, εν προκειμένω τη δημιουργία νέου parking. */
		
		while(1){ /* Βρόχος εισαγωγής του ονόματος του parking. */
			printf("\tPlease enter the parking's name: "); /* Εκτύπωση προτροπής για την εισαγωγή του ονόματος του parking. */

			scanf(" %[^\n]", buffer); /* Ανάγνωση του ονόματος του parking. */
			strncpy(newparking.parking_name, buffer, 16); /* Αντιγραφή τουλάχιστον των 16 πρώτων χαρακτήρων από την προσωρινή μεταβλητή buffer στην newparking.parking_name. */

			if(strlen(buffer)>15) /* Eκχώρηση ενός null character στην 16η θέση σε περίπτωση που η είσοδος ήταν μεγαλυτέρου μεγέθους. */
				newparking.parking_name[15]='\0';

			write(sockdes, newparking.parking_name, sizeof(newparking.parking_name)); /* Αποστολή του ονόματος του parking στον server για την πραγματοποίηση ελέγχου. */
			read(sockdes, &exists, sizeof(exists)); /* Ανάγνωση από τον server για το αν υπάρχει το σταλθέν όνομα. */

			if(exists==SUCCESS) /* Έλεγχος της exists για το αν υπάρχει το όνομα του parking ή όχι. */
				printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος ύπαρξης του δοθέντος ονόματος και προτροπή εισαγωγής διαφορετικού. */
					"This name already exists, please try a different one.\n"
					"--------------------------------------------------------------------------\n");
			else /* Εάν δεν υπάρχει το όνομα, τότε συνεχίζει παρακάτω. */
				break; /* Έξοδος από το βρόχο εισαγωγής του ονόματος. */
		}

		printf("\tPlease enter a short description: "); /* Εκτύπωση προτροπής για την εισαγωγή μιας σύντομης περιγραφής του parking. */
		scanf(" %[^\n]", buffer); /* Ανάγνωση της περιγραφής του parking. */
			strncpy(newparking.description, buffer, 81); /* Αντιγραφή τουλάχιστον των 80 πρώτων χαρακτήρων από την προσωρινή μεταβλητή buffer στην newparking.description. */
			if(strlen(buffer)>80) /* Eκχώρηση ενός null character στην 80η θέση σε περίπτωση που η είσοδος ήταν μεγαλυτέρου μεγέθους. */
				newparking.description[80]='\0';
		
		printf("\tPlease enter the parking's price (in euros): "); /* Εκτύπωση προτροπής για την εισαγωγή της τιμής του parking. */
		scanf("%f", &newparking.price); /* Ανάγνωση της τιμής του parking. */

		while(newparking.price<=0.0){ /* Βρόχος ελέγχου για την τιμή του parking, μέχρι να δοθεί μη αρνητική τιμή. */
			printf("Error: wrong amount given.\n" /* Εκτύπωση σφάλματος κατά την καταχώρηση της τιμής του parking. */
			       "\tPlease reenter the desired amount: "); /* Εκτύπωση προτροπής για την επανεισαγωγή της τιμής του parking. */
			scanf("%f", &newparking.price); /* Ανάγνωση της τιμής του parking. */
		}

		if(write(sockdes, &newparking, sizeof(newparking))<0){ /* Αποστολή των στοιχείων του parking στον server και μερικός έλεγχος επιτυχίας της αποστολής. */
			printf( "Error: could not create a new parking.\n" /* Εκτύπωση μηνύματος σφάλματος σύνδεσης και δημιουργίας νέου parking. */
				"Your connection was terminated.\n");
		}

		if(read(sockdes, &newparking, sizeof(newparking))<0){ /* Ανάγνωση των στοιχείων του νέου parking για επιβεβαίωση. */
				perror("Client error: read."); /* Εκτύπωση μηνύματος σφάλματος. */
				exit(1); /* Κλείσιμο της διεργασίας του client. */
		}

		printf("\nParking named %s, with %.2f€ cost and %d slots ", /* Εκτύπωση επιτυχούς δημιουργίας νέου parking. */
			newparking.parking_name , newparking.price , newparking.free);
		printf("was successfully created.\n");  
			
		
	}
	close(sockdes); /* Κλείσιμο του socket επικοινωνίας. */ 
}

void view_driver_last_reservation(){ /* Συνάρτηση για την εμφάνιση της τελευταίας κράτησης μιας οδηγού. */
	const int operation=6; /* Δήλωση σταθερής μεταβλητής για τον προσδιορισμό σταθερού αριθμού αντιστοίχισης σε μια λειτουργία και διευκόλυνση διαχωρισμού και επιλογής στον server. */
	struct client_account new_driver; /* Δήλωση τοπικής μεταβλητής client_account για τη διευκόλυνση αποθήκευσης δεδομένων και επικοινωνίας. */
	int no_park; /* Δήλωση μεταβλητής που δείχνει αν η οδηγός έχει πραγματοποιήσει ποτέ κράτηση σε κάποιο parking. */

	if((sockdes=socket(AF_UNIX, SOCK_STREAM, 0))<0){ /* Δημιουργία socket επικοινωνίας μεταξύ client-server και έλεγχος για περίπτωση εμφάνισης σφάλματος. */
		perror("Client error: socket.");
		exit(1);
	}

	if(connection()){ /* Κλήση συνάρτησης connection() για την πραγματοποίηση σύνδεσης με τον server και μερικός έλεγχος επιτυχίας. */
		write(sockdes, &operation, sizeof(operation)); /* Αποστολή στον server της τιμής της μεταβλητής που προσδιορίζει την επιλεγμένη λειτουργία, εν προκειμένω την εμφάνιση της τελευταίας κράτησης μιας οδηγού. */

		while(1){
			search_account(new_driver); /* Κλήση της συνάρτησης search_account() για την αναζήτηση και επιβεβαίωση της ύπαρξης του λογαριασμού της οδηγού. */
			read(sockdes, &no_park, sizeof(no_park)); /* Ανάγνωση από τον server της τιμής της μεταβλητής no_park που δείχνει αν έχει κάνει η οδηγός κάποια κράτηση στο παρελθόν. */
			
			if(no_park==0){ /* Έλεγχος για το ιστορικό κρατήσεων μιας οδηγού. */
				printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος για μη πραγματοποίηση κρατήσεων από την οδηγό ακόμα. */
					"Sorry, you have not made a reservation yet.\n");
			}
			else{
				read(sockdes, &new_driver, sizeof(struct client_account)); /* Ανάγνωση από τον server των στοιχείων της οδηγού. */
				printf(	"--------------------------------------------------------------------------\n" /* Εκτύπωση του τελευταίου parking που έγινε η κράτηση και του αριθμού των συνολικών κρατήσεων της οδηγού. */
					"Last reserved parking: %s \n"
					"Reservations made: %d \n",
					new_driver.reservations, new_driver.counter_park);
				break; /* Έξοδος από το βρόχο αναζήτησης κι εκτύπωσης. */
			}
			break; /* Έξοδος από το βρόχο αναζήτησης κι εκτύπωσης. */
		}
	}
	close(sockdes); /* Κλείσιμο του socket επικοινωνίας. */ 
}

void view_last_reservation(){ /* Συνάρτηση για την εμφάνιση της οδηγού που πραγματοποίησε την τελευταία κράτηση στο parking. */
	const int operation=7; /* Δήλωση σταθερής μεταβλητής για τον προσδιορισμό σταθερού αριθμού αντιστοίχισης σε μια λειτουργία και διευκόλυνση διαχωρισμού και επιλογής στον server. */
	struct parking newparking; /* Δήλωση τοπικής μεταβλητής parking για τη διευκόλυνση αποθήκευσης δεδομένων και επικοινωνίας. */
	int exists; /* Δήλωση μεταβλητής για τον έλεγχο ύπαρξης ενός parking. */	

	if((sockdes=socket(AF_UNIX, SOCK_STREAM, 0))<0){ /* Δημιουργία socket επικοινωνίας μεταξύ client-server και έλεγχος για περίπτωση εμφάνισης σφάλματος. */
		perror("Client error: socket."); /* Εκτύπωση μηνύματος σφάλματος. */
		exit(1); /* Κλείσιμο της διεργασίας του client. */
	}

	if(connection()){ /* Κλήση συνάρτησης connection() για την πραγματοποίηση σύνδεσης με τον server και μερικός έλεγχος επιτυχίας. */		
		write(sockdes, &operation, sizeof(operation)); /* Αποστολή στον server της τιμής της μεταβλητής που προσδιορίζει την επιλεγμένη λειτουργία, εν προκειμένω την εμφάνιση του ονόματος της οδηγού που πραγματοποίησε την τελευταία κράτηση στο parking. */
		exists=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή exists για τον επόμενο έλεγχο ύπαρξης parking. */
		
		printf("\tPlease enter the parking's name: "); /* Εκτύπωση προτροπής για την είσοδο του ονόματος του parking. */
		scanf(" %[^\n]", buffer); /* Ανάγνωση του ονόματος του parking. */
		strncpy(newparking.parking_name, buffer, 16); /* Αντιγραφή τουλάχιστον των 16 πρώτων χαρακτήρων από την προσωρινή μεταβλητή buffer στην newparking.parking_name. */

		if(strlen(buffer)>15) /* Eκχώρηση ενός null character στην 16η θέση σε περίπτωση που η είσοδος ήταν μεγαλυτέρου μεγέθους. */
			newparking.parking_name[15]='\0';
		
		while(exists==-1){ /* Βρόχος ελέγχου και εκτύπωσης στοιχείων. */
			write(sockdes, newparking.parking_name, sizeof(newparking.parking_name)); /* Αποστολή του ονόματος του parking στον server για αναζήτηση και επιβεβαίωση ύπαρξής του. */
			read(sockdes, &exists, sizeof(exists)); /* Ανάγνωση από τον server της τιμής της μεταβλητής exists για την ύπαρξη ή μη του parking. */

			if(exists==-1){ /* Έλεγχος για την ύπαρξη ή μη του parking. */
				printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος για τη μη ύπαρξη parking και προτροπή εισαγωγής διαφορετικού ονόματος. */
					"This parking doesn't exist, please try again.\n"
					"\tEnter the parking's name: ");

			scanf(" %[^\n]", buffer); /* Ανάγνωση του ονόματος του parking. */
			strncpy(newparking.parking_name, buffer, 16); /* Αντιγραφή τουλάχιστον των 16 πρώτων χαρακτήρων από την προσωρινή μεταβλητή buffer στην newparking.parking_name. */

			if(strlen(buffer)>15) /* Eκχώρηση ενός null character στην 16η θέση σε περίπτωση που η είσοδος ήταν μεγαλυτέρου μεγέθους. */
				newparking.parking_name[15]='\0';
			}
			else{ /* Εάν υπάρχει το parking, τότε συνεχίζει. */
				read(sockdes, &newparking, sizeof(struct parking)); /* Ανάγνωση των στοιχείων του parking από τον server. */

				if(newparking.driver_number==0){ /* Έλεγχος του αριθμού των προηγούμενων κρατήσεων. */
					printf( "\n--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος για την απουσία παλαιότερων κρατήσεων στο parking. */
						"Sorry, no one has parked here yet.\n");
				}
				else{ /* Αν υπάρχουν παλαιότερες κρατήσεις, τότε συνεχίζει. */
					printf(	"--------------------------------------------------------------------------\n" /* Εκτύπωση των στοιχείων του parking που ζητούνται. */
						"\t\t\t× PARKING'S %s INFO ×\n"
						"--------------------------------------------------------------------------\n"
						"Last driver parked here: %s \n"
						"Number of visitors today: %d \n"
						"--------------------------------------------------------------------------\n",
						newparking.parking_name, newparking.last, newparking.driver_number);
		    		}
		     		break; /* Έξοδος από το βρόχο ελέγχου και εκτύπωσης στοιχείων. */
			}
        	}
	}
	close(sockdes); /* Κλείσιμο του socket επικοινωνίας. */
}

void search_account(struct client_account newdriver){ /* Συνάρτηση για την αναζήτηση και εκτύπωση του λογαριασμού μιας οδηγού. */
	int name_found=-1; /* Δήλωση μεταβλητής για τον έλεγχο ύπαρξης του ονόματος που δόθηκε. */
	char name[40]; /* Δήλωση τοπικής μεταβλητής για τη διευκόλυνση αποθήκευσης του ονόματος και της επικοινωνίας. */

	while(1){ /* Βρόχος εισαγωγής του ονόματος της οδηγού. */
		printf("\t\t\tEnter the driver's name: ");  /* Εκτύπωση προτροπής για την εισαγωγή του ονόματος της οδηγού. */
		scanf(" %[^\n]", buffer); /* Ανάγνωση του ονόματος της οδηγού. */
		strncpy(name, buffer, 41); /* Αντιγραφή τουλάχιστον των 40 πρώτων χαρακτήρων από την προσωρινή μεταβλητή buffer στην name. */

		if(strlen(buffer)>40) /* Eκχώρηση ενός null character στην 40η θέση σε περίπτωση που η είσοδος ήταν μεγαλυτέρου μεγέθους. */
			name[40]='\0';

		write(sockdes, name, sizeof(name)); /* Αποστολή του ονόματος στον server. */
		read(sockdes, &name_found, sizeof(name_found)); /* Ανάγνωση από τον server για το αν υπάρχει το σταλθέν όνομα. */

		if(name_found==-1) /* Έλεγχος για την ύπαρξη ή όχι του ονόματος και αντίστοιχη λειτουργία. */
			printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος για τη μη ύπαρξη του λογαριασμού που αναζητείται. */
				"This account doesn't exist, please try again.\n"
				"--------------------------------------------------------------------------\n");	
		else /* Εάν υπάρχει ο λογαριασμός. */
			break; /* Έξοδος από το βρόχο εισαγωγής ονόματος. */
	}

	read(sockdes, &newdriver, sizeof(struct client_account)); /* Ανάγνωση των στοιχείων της οδηγού από τον server. */

	printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση των στοιχείων της οδηγού. */
		"\t\t\t× DRIVER'S INFO ×\n"
		"--------------------------------------------------------------------------\n"
		"Name: %s\n"
		"Money: %.2lf €\n",
		newdriver.name, newdriver.money);
}

int connection(){ /* Συνάρτηση για την πραγματοποίηση σύνδεσης μεταξύ του server και του client. */
	printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος για έναρξη της προσπάθειας σύνδεσης με τον server. */
		"Connecting to the server...\n");

	sock_add.sa_family=AF_UNIX; /* Προσδιορισμός διεύθυνσης για επικοινωνία εντός του ίδιου συστήματος. */
	strcpy(sock_add.sa_data, UNIXSTR_PATH); /* Προσδιορισμός πρωτοκόλλου για επικοινωνία server-client στο ίδιο σύστημα. */

	int length=sizeof(sock_add.sa_family)+strlen(sock_add.sa_data); /* Προσδιορισμός μήκους του string που θα διαβάσει στη συνέχεια η συνάρτηση connect(). */

	if(connect(sockdes, &sock_add, length)<0){ /* Σύνδεση client-server μέσω του socket επικοινωνίας. */ 
		printf( "The server did not reply.\n" /* Εκτύπωση μηνύματος αποτυχίας σύνδεσης. */
			"The connection was terminated.\n"
			"--------------------------------------------------------------------------\n");
		return 0; /* Επιστροφή τιμής 0 που δεικνύει την αποτυχία σύνδεσης με τον server. */
	}
	else{
		printf( "The connection was successfuly established.\n" /* Εκτύπωση μηνύματος επίτευξης σύνδεσης. */
			"--------------------------------------------------------------------------\n");
		return 1; /* Επιστροφή τιμής 1 που δεικνύει την επίτευξη σύνδεσης με τον server. */
	}
}

void kill_client(){ /* Συνάρτηση εξουδετέρωσης μιας διεργασίας client. */
	printf("\n---------------------------------------------------------------------------\n" /* Εκτύπωση μηνύματος τερματισμού του client. */
		"You are dead, have a nice day!\n"
		"--------------------------------------------------------------------------\n");
	exit(0); /* Κλείσιμο της διεργασίας του client. */
}

void goodbye_message(){ /* Συνάρτηση εκτύπωσης αποχαιρετηστήριου μηνύματος. */
	printf( "--------------------------------------------------------------------------\n" /* Εκτύπωση αποχαιρετηστήριου μηνύματος. */
		"Thank you for using our services, we'd be glad to see you again!\n\n"
		"\t\t\t\t\t\tThe CEID OS parking team.\n"
		"--------------------------------------------------------------------------\n");
}
