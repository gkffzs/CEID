#include <sys/types.h> /* Δήλωση βιβλιοθηκών που χρησιμοποιούνται στο πρόγραμμα. */
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

#define UNIXSTR_PATH "/tmp/unix.str" /* Καθορισμός του path που θα χρησιμοποιηθεί για την επικοινωνία μεταξύ server-client. */
#define SHM_SIZE 1000*sizeof(struct client_account)+200*sizeof(struct parking)+2 /* Προσδιορισμός του μεγέθους της κοινής μνήμης που θα χρησιμοποιηθεί σύμφωνα με τα δεδομένα της εκφώνησης της άσκησης. Από τη στιγμή που μπορούν να υπάρχουν το πολύ 1000 οδηγοί τότε για να εξυπηρετηθούν όλοι απαιτούνται τουλάχιστον 200 parking. */
#define SHM_KEY IPC_PRIVATE /* Προσδιορισμός του αριθμητικού κλειδιού για τη δημιουργία της κοινής μνήμης. */
#define LISTEN_QUEUE 5 /* Προσδιορισμός αριθμού client που μπορούν να περιμένουν για εξυπηρέτηση στο socket. */
#define SEM_NAME "os_project" /* Προσδιορισμός ονόματος του σημαφόρου που χρησιμοποιείται. */

void sig_chld(); /* Δήλωση καθορισμένων συναρτήσεων που χρησιμοποιούνται για τις διάφορες επιθυμητές λειτουργίες. */
void kill_server();

int shm_id, sock_des, pid, error;
int *count; /* Δήλωση δείκτη που θα δείχνει στον αριθμό των λογαριασμών, που θα βρίσκεται στην πρώτη θέση της κοινής μνήμης. */
struct client_account *d_account; /* Δήλωση δείκτη στην πρώτη θέση της κοινής μνήμης όπου θα αποθηκεύονται οι οδηγοί. */
struct parking *p_account; /* Δήλωση δείκτη στην πρώτη θέση της κοινής μνήμης όπου θα αποθηκεύονται τα parking. */
struct sockaddr sock_add, fsock_add;
int new_handle;
sem_t *my_sem;
socklen_t cln_len;


struct parking{ /* Δήλωση του struct για τα parking. */
	char parking_name[15]; /* Δήλωση μεταβλητής για την αποθήκευση του ονόματος του parking. */
	char description[80]; /* Δήλωση μεταβλητής για την αποθήκευση της περιγραφής του parking. */
	float price; /* Δήλωση μεταβλητής για την αποθήκευση της τιμής του parking. */
	char last[40]; /* Δήλωση μεταβλητής για την αποθήκευση της οδηγού που έκανε την τελευταία κράτηση. */
	int empty; /* Δήλωση μεταβλητής για την αποθήκευση του αριθμού των οδηγών που έχουν κάνει κράτηση στο parking. */
	int free; /* Δήλωση μεταβλητής που δείχνει τον αριθμό των ελεύθερων θέσεων στο parking. */
} parking[200];	/* Δήλωση ενός πίνακα από parking με 200 κελιά. */

struct client_account{ /* Δήλωση του struct για τις οδηγούς. */
	char name[40]; /* Δήλωση μεταβλητής για την αποθήκευση του ονόματος της οδηγού. */
	float money; /* Δήλωση μεταβλητής για την αποθήκευση των χρημάτων που διαθέτει η οδηγός. */
	char reservations[15]; /* Δήλωση μεταβλητής για την αποθήκευση του ονόματος parking στο οποίο έγινε από την οδηγό η τελευταία κράτηση. */
	int parked; /* Δήλωση μεταβλητής που χρησιμοποιείται για να διευκρινιστεί αν η οδηγός έχει κάνει ήδη κράτηση ή όχι. */
	int counter_park; /* Δήλωση μεταβλητής για την αποθήκευση του αριθμού των υπάρχοντων parking, ώστε να πραγματοποιείται η εκτύπωση τους πριν μια κράτηση και να διευκολύνεται η επιλογή μεταξύ αυτών. */
} client[1000]; /* Δήλωση ενός πίνακα από client_account με 1000 κελιά. */

int main(){ /* Κύριο πρόγραμμα. */
	char tempname[40]; /* Δήλωση μεταβλητής για την προσωρινή αποθήκευση ονόματος οδηγού. */
	float tempmoney; /* Δήλωση μεταβλητής για την προσωρινή αποθήκευση του ποσού των χρημάτων. */
	int operation; /* Δήλωση μεταβλητής για τη διευκόλυνση επιλογής μεταξύ των λειτουργιών. */
	int length; /* Δήλωση μεταβλητής για την αποθήκευση του μήκους που θα αναγνώσει η συνάρτηση bind(). */
	int name_found; /* Δήλωση μεταβλητών που λειτουργούν ως flags σε ελέγχους. */
	int name_found2;
	int i; /* Δήλωση μετρητών που χρησιμοποιούνται σε βρόχους. */
	int i2;
	
		
	if((my_sem=sem_open(SEM_NAME, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR, 1))==SEM_FAILED){ /* Δημιουργία σημαφόρου και έλεγχος αποτυχίας της προσπάθειας. */
		perror("\nFailure to initialize the semaphore.\n"); /* Εκτύπωση σφάλματος σε περίπτωση αποτυχίας δημιουργίας σημαφόρου. */
		exit(1); /* Έξοδος από το πρόγραμμα. */
	}
	
	if((shm_id=shmget(SHM_KEY, SHM_SIZE, 0600 | IPC_CREAT))<0){ /* Δημιουργία κοινής μνήμης και έλεγχος αποτυχίας της προσπάθειας. */
		perror("\nFailure to create a shared memory segment.\n"); /* Εκτύπωση σφάλματος σε περίπτωση αποτυχίας δημιουργίας κοινής μνήμης. */
		exit(1); /* Έξοδος από το πρόγραμμα. */
	}
	
	if((count=(int *)shmat(shm_id, NULL, 0))==(int *)-1){ /* Προσάρτηση της κοινής μνήμης μέσω δεικτοδότησης στην πρώτη θέση της, η οποία χρησιμοποιείται για την αποθήκευση του αριθμού των οδηγών που θα δημιουργηθούν και έλεγχος αποτυχίας της προσπάθειας. */
		perror("\nFailure to attach the shared memory segment.\n"); /* Εκτύπωση σφάλματος σε περίπτωση αποτυχίας προσάρτησης της κοινής μνήμης. */
		exit(1); /* Έξοδος από το πρόγραμμα. */
	}
	
	d_account=(struct client_account *)(count+1); /* Προσδιορισμός του δείκτη των οδηγών μία θέση μετά τη θέση του μετρητή λογαριασμών. */
	p_account=(struct parking *)(count+1001); /* Προσδιορισμός του δείκτη των parking 1001 θέσεις μετά τη θέση του μετρητή λογαριασμών. */
		
	if((sock_des=socket(AF_UNIX, SOCK_STREAM, 0))<0){ /* Δημιουργία του socket επικοινωνίας και έλεγχος αποτυχίας της προσπάθειας. */
		perror("Failure to create a socket.\n"); /* Εκτύπωση σφάλματος σε περίπτωση αποτυχίας δημιουργίας του socket επικοινωνίας. */
		exit(1); /* Έξοδος από το πρόγραμμα. */
	}
	
	unlink(UNIXSTR_PATH); /* Προληπτική διαγραφή προηγούμενου socket. */
	bzero( &sock_add, sizeof(sock_add)); /* Αντίστοιχος μηδενισμός της διεύθυνσης του socket. */
	sock_add.sa_family=AF_UNIX; /* Προσδιορισμός πρωτοκόλλου για επικοινωνία server-client στο ίδιο σύστημα. */
	strcpy(sock_add.sa_data, UNIXSTR_PATH); /* Προσδιορισμός του path που θα χρησιμοποιηθεί για τη σύνδεση. */

	length=sizeof(sock_add.sa_family)+sizeof(sock_add.sa_data); /* Προσδιορισμός μήκους του string που θα διαβάσει στη συνέχεια η συνάρτηση bind(). */

	signal(SIGCHLD, sig_chld); /* Ρύθμιση και προσδιορισμός του signal handler για την αποφυγή δημιουργίας διεργασιών zombie. */
	signal(SIGINT, kill_server); /* Ρύθμιση και προσδιορισμός του signal handler για το κλείσιμο της διεργασίας και αποδέσμευση της κοινής μνήμης με τον συνδυασμό CTRL+C. */
	
	printf("The server has been successfully initialized.\n"); /* Εκτύπωση μηνύματος επιτυχούς έναρξης του server. */
	
	if(bind(sock_des, &sock_add, length)<0){ /* Δέσμευση (bind) του socket επικοινωνίας που δημιουργήθηκε. */
		perror("Failure to bind the socket.\n"); /* Εκτύπωση σφάλματος σε περίπτωση αποτυχίας δέσμευσης του socket επικοινωνίας που δημιουργήθηκε. */
		exit(1); /* Έξοδος από το πρόγραμμα. */
	}

	if(listen(sock_des, LISTEN_QUEUE)<0){ /* Καθορισμός του socket επικοινωνίας ως listening socket. */
		perror("Failure to listen for clients.\n"); /* Εκτύπωση σφάλματος σε περίπτωση αποτυχίας καθορισμού του socket επικοινωνίας ως listening socket. */
		exit(1); /* Έξοδος από το πρόγραμμα. */
	}

	while(1){ /* Βρόχος για την εξυπηρέτηση των client. */
		if ((new_handle=accept(sock_des, &fsock_add, &cln_len))<0){ /* Αποδοχή επικοινωνίας μέσω του socket επικοινωνίας new_handle και μερικός έλεγχος επιτυχίας της προσπάθειας. */
			perror("Failure to accept a new client.\n"); /* Εκτύπωση μηνύματος αποτυχίας αποδοχής αίτησης σύνδεσης από client. */
			exit(1); /* Έξοδος από το πρόγραμμα. */
		}

		pid=fork(); /* Δημιουργία διεργασίας παιδιού (child process). */

		if(pid==0){ /* Έλεγχος για το αν το ακόλουθο τμήμα κώδικα εκτελείται από την child process. */
			close(sock_des); /* Κλείσιμο του listening socket από την child process. */

			if(read(new_handle, &operation, sizeof(operation))<0){ /* Ανάγνωση της επιλεγμένης λειτουργίας από τον client και μερικός έλεγχος για την επιτυχία της ανάγνωσης. */
				perror("Failure to read the selected operation from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης της λειτουργίας. */
				exit(1); /* Έξοδος από το πρόγραμμα. */
			}
 					
			switch(operation){ /* Δομή επιλογής switch για τον προσδιορισμό της επιθυμητής λειτουργίας. */
				case 1: /* Περίπτωση δημιουργίας νέου λογαριασμού οδηγού. */
					while(1){ /* Βρόχος αναζήτησης ονόματος οδηγού. */
						name_found=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή name_found για τον επόμενο έλεγχο ύπαρξης του ονόματος. */

						if (read(new_handle, tempname, sizeof(tempname))<0){ /* Ανάγνωση του ονόματος από τον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to read the name from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ονόματος. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						for(i=0; i<*count; i++){ /* Βρόχος συγκρίσεων. */
							if (!strcmp(d_account[i].name, tempname)){ /* Σύγκριση του προσωρινού ονόματος με τα αποθηκευμένα. */ 
								name_found=0; /* Αν βρεθεί υπάρχουσα καταχώρηση, τότε εκχωρείται στη name_found η τιμή 0. */
								break; /* Έξοδος από το βρόχο συγκρίσεων. */
							}
						}

						if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας της αποστολής της τιμής. */ 
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						if(name_found==-1) /* Αν δεν υπάρχει το όνομα. */
							break; /* Έξοδος από το βρόχο αναζήτησης. */
					}
	
					sem_wait(my_sem); /* Ενεργοποίηση αναμονής του σημαφόρου καθώς τροποποιούνται στη συνέχεια τα περιεχόμενα της μνήμης. */	

					if(read(new_handle, &d_account[*count], sizeof(struct client_account))<0){ /* Ανάγνωση των στοιχείων του λογαριασμού από τον client και μερικός έλεγχος επιτυχίας. */
						perror("Failure to read the account from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης των στοιχείων. */
						exit(1); /* Έξοδος από το πρόγραμμα. */
					}

					d_account[*count].counter_park=0; /* Μηδενίζουμε το μετρητή των parking. */
					d_account[*count].parked=0; /* Αρχικοποιούμε με 0 τη μεταβλητή που δείχνει αν έχει παρκάρει κάπου η οδηγός. */
				
					if(write(new_handle, &d_account[*count], sizeof(struct client_account))<0){ /* Αποστολή των στοιχείων του λογαριασμού στον client και μερικός έλεγχος επιτυχίας. */
						perror("Failure to write the account to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων. */
						exit(1); /* Έξοδος από το πρόγραμμα. */	
					}

					sem_post(my_sem); /* Παύση χρήσης του σημαφόρου καθότι τέλειωσε η αποθήκευση δεδομένων στη μνήμη. */

					if(*count<1000) /* Τυπικός έλεγχος για να μην ξεπεραστούν οι 1000 καταχωρήσεις οδηγών. */
						(*count)++; /* Αύξηση του μετρητή λογαριασμών. */

					break; /* Έξοδος από τη δομή επιλογής switch για τις επιμέρους λειτουργίες. */
				case 2:	/* Περίπτωση πραγματοποίησης νέας κράτησης σε parking. */					
					while(1){ /* Βρόχος εισαγωγής στοιχείων οδηγού και επιλογής parking. */
						if(read(new_handle, tempname, sizeof(tempname))<0){ /* Ανάγνωση του ονόματος από τον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to read the name from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ονόματος. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						i=0; /* Αρχικοποίηση της μεταβλητής για τη χρήση της στον ακόλουθο βρόχο. */ 
						name_found=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή name_found για τον επόμενο έλεγχο ύπαρξης του ονόματος. */

						while((i<*count)&&(name_found==-1)){ /* Βρόχος συγκρίσεων. */
							if(!strcmp(d_account[i].name, tempname)){ /* Σύγκριση του προσωρινού ονόματος με τα αποθηκευμένα. */ 
								name_found=0; /* Αν βρεθεί υπάρχουσα καταχώρηση, τότε εκχωρείται στη name_found η τιμή 0. */

								if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας της αποστολής της τιμής. */ 
									exit(1); /* Έξοδος από το πρόγραμμα. */
								}

								if(write(new_handle, &d_account[i], sizeof(struct client_account))<0){ /* Αποστολή των στοιχείων του λογαριασμού στον client και μερικός έλεγχος επιτυχίας. */
						perror("Failure to write the account to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων. */
									exit(1); /* Έξοδος από το πρόγραμμα. */
								}							    
							}
							else /* Αν δεν είναι ίδια τα ονόματα της σύγκρισης. */
								i++; /* Αύξηση του μετρητή για να προχωρήσει. */
						}

						if(name_found==0) /* Αν υπάρχει το όνομα της οδηγού. */
							break; /* Έξοδος από τον κύριο βρόχο. */
						else /* Αν δεν υπάρχει. */
					     		if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client και μερικός έλεγχος επιτυχίας. */
								perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */
								exit(1); /* Έξοδος από το πρόγραμμα. */
					     		}
					} 
				
					for(i2=0; i2<=200; i2++){ /* Βρόχος εκτύπωσης διαθέσιμων parking. */
						if(write(new_handle, &p_account[i2], sizeof(struct parking))<0){ /* Ανάγνωση των στοιχείων του parking και μερικός έλεγχος επιτυχίας. */
							perror("Failure to write the parking to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης των στοιχείων του parking. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}
					}
			
					while(1){ /* Βρόχος αναζήτησης του ονόματος του parking. */
						name_found2=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή name_found2 για τον επόμενο έλεγχο ύπαρξης του ονόματος. */
						i2=0; /* Αρχικοποίηση της μεταβλητής για τη χρήση της στον ακόλουθο βρόχο. */ 
					
						if(read(new_handle, tempname, sizeof(tempname))<0){ /* Ανάγνωση του ονόματος από τον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to read the name from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ονόματος. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						while((i2<*count)&&(name_found2==-1)){ /* Βρόχος συγκρίσεων. */
							if(!strcmp(p_account[i2].parking_name, tempname)) /* Σύγκριση του προσωρινού ονόματος με τα αποθηκευμένα. */     
								name_found2=0; /* Αν βρεθεί υπάρχουσα καταχώρηση, τότε εκχωρείται στη name_found2 η τιμή 0. */
							else /* Αν δεν είναι ίδια τα ονόματα της σύγκρισης. */
								i2++; /* Αύξηση του μετρητή για να προχωρήσει. */
						}

						if(write(new_handle, &name_found2, sizeof(name_found2))<0){ /* Αποστολή της τιμής της name_found2 στον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to write the parking confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */ 	
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}
					
						if(name_found2==0) /* Αν το όνομα του parking υπάρχει. */
							break; /* Έξοδος από το βρόχο αναζήτησης. */	
					}	

					if(write(new_handle, &p_account[i2], sizeof(struct parking))<0){ /* Αποστολή των στοιχείων του parking στον client και μερικός έλεγχος επιτυχίας. */
						perror("Failure to write the parking to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων. */
						exit(1); /* Έξοδος από το πρόγραμμα. */
					}

					if(write(new_handle, &d_account[i], sizeof(struct client_account))<0){ /* Αποστολή των στοιχείων του λογαριασμού στον client και μερικός έλεγχος επιτυχίας. */
						perror("Failure to write the account to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων. */
						exit(1); /* Έξοδος από το πρόγραμμα. */
					}
					
					sem_wait(my_sem); /* Ενεργοποίηση αναμονής του σημαφόρου καθώς τροποποιούνται στη συνέχεια τα περιεχόμενα της μνήμης. */

					if((d_account[i].money>=p_account[i2].price)&&(p_account[i2].free>=1)&&(d_account[i].parked==0)){
						strcpy(p_account[i2].last , d_account[i].name); /* Αποθήκευση ονόματος οδηγού για την εμφάνιση του ως τελευταία κράτηση πελάτη που πραγματοποιήθηκε στο parking. */
						strcpy(d_account[i].reservations, p_account[i2].parking_name); /* Αποθήκευση ονόματος parking για την εμφάνιση του ως τελευταίο parking στο οποίο έκανε κράτηση η οδηγός. */					

						if(p_account[i2].empty>=0) /* Έλεγχος για την ορθότητα της τιμής του μετρητή. */
							p_account[i2].empty++; /* Αύξηση του μετρητή των οδηγών που έχουν κάνει κράτηση κατά ένα. */

						if(d_account[i].counter_park>=0) /* Έλεγχος για την ορθότητα της τιμής του μετρητή. */
							d_account[i].counter_park++; /* Αύξηση του μετρητή των κρατήσεων της οδηγού κατά ένα. */

						d_account[i].parked=1; /* Ένδειξη ότι πλέον έχει παρκάρει κάπου η οδηγός. */
						p_account[i2].free--; /* Μειώνουμε τις ελεύθερες θέσεις του parking κατά μία. */
					}

					sem_post(my_sem); /* Παύση χρήσης του σημαφόρου καθότι τέλειωσε η αποθήκευση δεδομένων στη μνήμη. */						
												
					sleep(120); /* Ο server (child process) τίθεται σε κατάσταση ύπνου για 2 λεπτά, όσο επιτρέπεται να διαρκεί η κράτηση μιας οδηγού σε μια θέση parking. */
					
					sem_wait(my_sem); /* Ενεργοποίηση αναμονής του σημαφόρου καθώς τροποποιούνται στη συνέχεια τα περιεχόμενα της μνήμης. */

					if((p_account[i2].free>=0)&&(p_account[i2].free<5)&&(d_account[i].parked==1)){ /* Έλεγχος ικανοποίησης πολλαπλών συνθηκών, αν υπάρχουν θέσεις στο parking κι αν έχει παρκάρει η οδηγός. */
						d_account[i].money-=p_account[i2].price; /* Αφαίρεση του κόστους κράτησης του parking από τα χρήματα της οδηγού. */
						d_account[i].parked=0; /* Ένδειξη ότι η οδηγός δεν έχει παρκάρει κάπου τώρα. */
						p_account[i2].free++; /* Αυξάνουμε πάλι τις ελεύθερες θέσεις του parking κατά μία. */
					}	
			
					sem_post(my_sem); /* Παύση χρήσης του σημαφόρου καθότι τέλειωσε η αποθήκευση δεδομένων στη μνήμη. */

					break; /* Έξοδος από τη δομή επιλογής switch για τις επιμέρους λειτουργίες. */
				case 3: /* Περίπτωση εμφάνισης πληροφοριών ενός λογαριασμού. */
					while(1){ /* Βρόχος εισαγωγής ονόματος οδηγού. */
						if(read(new_handle, tempname, sizeof(tempname))<0){ /* Ανάγνωση του ονόματος από τον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to read the name from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ονόματος. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						i=0; /* Αρχικοποίηση της μεταβλητής για τη χρήση της στον ακόλουθο βρόχο. */ 
						name_found=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή name_found για τον επόμενο έλεγχο ύπαρξης του ονόματος. */

						while((i<*count)&&(name_found==-1)){ /* Βρόχος αναζήτησης του ονόματος. */
							if(!strcmp(d_account[i].name, tempname)){ /* Σύγκριση του προσωρινού ονόματος με τα αποθηκευμένα. */
								name_found=0; /* Αν βρεθεί υπάρχουσα καταχώρηση, τότε εκχωρείται στη name_found η τιμή 0. */

								if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client και μερικός έλεγχος επιτυχίας. */
									perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */
									exit(1); /* Έξοδος από το πρόγραμμα. */
								}								

								if(write(new_handle, &d_account[i], sizeof(struct client_account))<0){ /* Αποστολή των στοιχείων της οδηγού στον client και μερικός έλεγχος επιτυχίας. */
									perror("Failure to write the account to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων της οδηγού. */
									exit(1); /* Έξοδος από το πρόγραμμα. */
								}   
							}
							else /* Αν δε βρεθεί το όνομα από τη σύγκριση. */
								i++; /* Αύξηση του μετρητή για να προχωρήσει παρακάτω. */
						}

						if(name_found==0) /* Αν υπάρχει το όνομα. */
							break; /* Έξοδος από το βρόχο αναζήτησης. */
						else /* Αν δεν υπάρχει το όνομα. */
							if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client και μερικός έλεγχος επιτυχίας. */
								perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */
								exit(1); /* Έξοδος από το πρόγραμμα. */ 
							}
					}	

					break; /* Έξοδος από τη δομή επιλογής switch για τις επιμέρους λειτουργίες. */                                            
				 case 4: /* Περίπτωση κατάθεσης χρημάτων σε υπάρχοντα λογαριασμό. */
					while(1){ /* Βρόχος εισαγωγής ονόματος οδηγού. */
						if(read(new_handle, tempname, sizeof(tempname))<0){ /* Ανάγνωση του ονόματος από τον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to read the name from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ονόματος. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						i=0; /* Αρχικοποίηση της μεταβλητής για τη χρήση της στον ακόλουθο βρόχο. */ 
						name_found=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή name_found για τον επόμενο έλεγχο ύπαρξης του ονόματος. */

						while((i<*count)&&(name_found==-1)){ /* Βρόχος αναζήτησης του ονόματος. */
							if(!strcmp(d_account[i].name, tempname)){ /* Σύγκριση του προσωρινού ονόματος parking με τα αποθηκευμένα. */
								name_found=0; /* Αν βρεθεί υπάρχουσα καταχώρηση parking, τότε εκχωρείται στη name_found2 η τιμή 0. */

								if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client και μερικός έλεγχος επιτυχίας. */
									perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */
									exit(1); /* Έξοδος από το πρόγραμμα. */ 
								}

								if(write(new_handle, &d_account[i], sizeof(struct client_account))<0){ /* Αποστολή των στοιχείων της οδηγού στον client και μερικός έλεγχος επιτυχίας. */
									perror("Failure to write the account to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων της οδηγού. */
									exit(1); /* Έξοδος από το πρόγραμμα. */
								}
							}
							else /* Αν δε βρεθεί το όνομα από τη σύγκριση. */
								i++; /* Αύξηση του μετρητή για να προχωρήσει παρακάτω. */
						}

						if(name_found==0) /* Αν υπάρχει το όνομα. */
							break; /* Έξοδος από το βρόχο αναζήτησης. */
						else /* Αν δεν υπάρχει το όνομα. */
							if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client. και μερικός έλεγχος επιτυχίας. */
								perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */
								exit(1); /* Έξοδος από το πρόγραμμα. */ 
							}
					}

					if(read(new_handle, &tempmoney, sizeof(tempmoney))<0){ /* Ανάγνωση του ποσού χρημάτων από τον client και μερικός έλεγχος επιτυχίας. */
						perror("Failure to read the money from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ποσού. */
						exit(1); /* Έξοδος από το πρόγραμμα. */
					}

					sem_wait(my_sem); /* Ενεργοποίηση αναμονής του σημαφόρου καθώς τροποποιούνται στη συνέχεια τα περιεχόμενα της μνήμης. */

					d_account[i].money+=tempmoney; /* Προσθήκη του επιθυμητού ποσού σ' αυτό του λογαριασμού. */
					
					sem_post(my_sem); /* Παύση χρήσης του σημαφόρου καθότι τέλειωσε η αποθήκευση δεδομένων στη μνήμη. */

					if(write(new_handle, &d_account[i], sizeof(struct client_account))<0){
						perror("Failure to write the account to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων της οδηγού. */
						exit(1); /* Έξοδος από το πρόγραμμα. */
					}

					break; /* Έξοδος από τη δομή επιλογής switch για τις επιμέρους λειτουργίες. */
				case 5: /* Περίπτωση δημιουργίας νέου parking. */
					while(1){ /* Βρόχος καθορισμού ονόματος του parking. */
						name_found2=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή name_found2 για τον επόμενο έλεγχο ύπαρξης parking. */

						if (read(new_handle, tempname, sizeof(tempname))<0){ /* Ανάγνωση του ονόματος του parking από τον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to read the name from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ονόματος του parking. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						for(i=0; i<*count; i++){ /* Βρόχος αναζήτησης ονόματος. */
							if (!strcmp(p_account[i].parking_name, tempname)){ /* Σύγκριση του προσωρινού ονόματος parking με τα αποθηκευμένα. */      
								name_found2=0; /* Αν βρεθεί υπάρχουσα καταχώρηση parking, τότε εκχωρείται στη name_found2 η τιμή 0. */
								break; /* Έξοδος από το βρόχο αναζήτησης. */
							}
						}

						if(write(new_handle, &name_found2, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found2 στον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to write the parking confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						if (name_found2==-1) /* Αν δεν υπάρχει το parking. */
							break; /* Έξοδος από το βρόχο καθορισμού. */
					}
	
					if(read(new_handle, &p_account[*count], sizeof(struct parking))<0){ /* Ανάγνωση των στοιχείων του parking από τον client και μερικός έλεγχος επιτυχίας. */
						perror("Failure to read the parking from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης των στοιχείων του parking. */
						exit(1); /* Έξοδος από το πρόγραμμα. */
					}
					sem_wait(my_sem); /* Ενεργοποίηση αναμονής του σημαφόρου καθώς τροποποιούνται στη συνέχεια τα περιεχόμενα της μνήμης. */

					p_account[*count].free=5; /* Προσδιορισμός ελεύθερων θέσεων parking. */
					p_account[*count].empty=0; /* Προσδιορισμός μη ύπαρξης κρατήσεων στο parking. */

					sem_post(my_sem); /* Παύση χρήσης του σημαφόρου καθότι τέλειωσε η αποθήκευση δεδομένων στη μνήμη. */
				
					if(write(new_handle, &p_account[*count], sizeof(struct parking))<0){ /* Αποστολή των στοιχείων του parking και μερικός έλεγχος επιτυχίας. */
						perror("Failure to write the parking to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων του parking. */
						exit(1); /* Έξοδος από το πρόγραμμα. */	
					}
					(*count)++;
					break; /* Έξοδος από τη δομή επιλογής switch για τις επιμέρους λειτουργίες. */ 	
				 case 6: /* Περίπτωση εμφάνισης της τελευταίας κράτησης μιας οδηγού. */
					while(1){ /* Βρόχος εισαγωγής και ελέγχου ονόματος. */
						if(read(new_handle, tempname, sizeof(tempname))<0){ /* Ανάγνωση του ονόματος από τον client και μερικός έλεγχος επιτυχίας. */
							perror( "Failure to read the name from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ονόματος. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						i=0; /* Αρχικοποίηση της μεταβλητής για τη χρήση της στον ακόλουθο βρόχο. */ 
						name_found=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή name_found για τον επόμενο έλεγχο ύπαρξης του ονόματος. */

						while((i<*count)&&(name_found==-1)){ /* Βρόχος αναζήτησης του ονόματος. */
							if(!strcmp(d_account[i].name, tempname)){ /* Σύγκριση του προσωρινού ονόματος με τα αποθηκευμένα. */
								name_found=0; /* Αν βρεθεί υπάρχουσα καταχώρηση, τότε εκχωρείται στη name_found η τιμή 0. */

								if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client και μερικός έλεγχος. */
									perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */
									exit(1); /* Έξοδος από το πρόγραμμα. */
								}
							
								if(write(new_handle, &d_account[i], sizeof(struct client_account))<0){ /* Αποστολή των στοιχείων της οδηγού και μερικός έλεγχος επιτυχίας της. */
									perror("Failure to write the account to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων του λογαριασμού. */
									exit(1); /* Έξοδος από το πρόγραμμα. */
								}
							}
							else /* Αν δεν υπάρχει αποθηκευμένο το όνομα. */
								i++; /* Αύξηση μετρητή για να προχωρήσει στην επόμενη καταχώρηση. */
						}
						
						if(name_found==0) /* Έλεγχος για το αν υπάρχει ή όχι το όνομα και αντίστοιχες ενέργειες. */
							break; /* Έξοδος από το βρόχο εισαγωγής και ελέγχου ονόματος. */
						else /* Αν δεν υπάρχει το όνομα. */
							if(write(new_handle, &name_found, sizeof(name_found))<0){ /* Αποστολή της τιμής της name_found στον client και μερικός έλεγχος επιτυχίας της. */
								perror("Failure to write the name confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της name_found. */
								exit(1); /* Έξοδος από το πρόγραμμα. */ 
							}
					}

					if(d_account[i].counter_park==0){ /* Έλεγχος για το αν υπάρχουν parking. */
						if(write(new_handle,&d_account[i].counter_park, sizeof(d_account[i].counter_park))<0){ /* Αποστολή του μετρητή parking και μερικός έλεγχος επιτυχίας. */
							perror("Failure to write the parking counter to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής του μετρητή parking. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}
					}
					else{ /* Αν υπάρχουν parking. */
						if(write(new_handle,&d_account[i].counter_park, sizeof(d_account[i].counter_park))<0){ /* Αποστολή του μετρητή parking και μερικός έλεγχος επιτυχίας. */
								perror("Failure to write the parking counter to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής του μετρητή parking. */
								exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						if(write(new_handle, &d_account[i], sizeof(struct client_account))<0){ /* Αποστολή των στοιχείων της οδηγού στον client και μερικός έλεγχος επιτυχίας της προσπάθειας. */
									perror("Failure to write the account to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων. */
									exit(1); /* Έξοδος από το πρόγραμμα. */
						}
					}
                                       	break; /* Έξοδος από τη δομή επιλογής switch για τις επιμέρους λειτουργίες. */
				case 7: /* Περίπτωση εμφάνισης τελευταίας καταχώρησης στο parking. */
					while(1){
						i2=0; /* Αρχικοποίηση της μεταβλητής για τη χρήση της στον ακόλουθο βρόχο. */ 
						name_found2=-1; /* Εκχώρηση τιμής -1 στη μεταβλητή name_found2 για τον επόμενο έλεγχο ύπαρξης του parking. */
						if(read(new_handle, tempname, sizeof(tempname))<0){ /* Ανάγνωση του ονόματος του parking από τον client και μερικός έλεγχος επιτυχίας. */
							perror("Failure to read the name from the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας ανάγνωσης του ονόματος. */ 
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}

						while((i2<*count)&&(name_found2==-1)){ /* Βρόχος αναζήτησης του ονόματος του parking. */
							if (!strcmp(p_account[i2].parking_name, tempname)) /* Σύγκριση του προσωρινού ονόματος parking με τα αποθηκευμένα. */     
								name_found2=0; /* Αν βρεθεί υπάρχουσα καταχώρηση, τότε εκχωρείται στη name_found2 η τιμή 0. */					
							else
								i2++; /* Αύξηση μετρητή για να προχωρήσει στην επόμενη καταχώρηση parking. */
						}

						if(write(new_handle, &name_found2, sizeof(name_found2))<0){ /* Αποστολή της τιμής της name_found2 στον client και μερικός έλεγχος επιτυχίας της προσπάθειας. */
							perror("Failure to write the parking confirmation to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής της τιμής. */
							exit(1); /* Έξοδος από το πρόγραμμα. */
						}
					
						if(name_found2==0) /* Έλεγχος αν το όνομα parking υπάρχει. */
							break; /* Έξοδος από το βρόχο αναζήτησης. */	
					}
	
					if(write(new_handle, &p_account[i2], sizeof(struct parking))<0){ /* Αποστολή στον client των στοιχείων του parking που ζητήθηκε και μερικός έλεγχος επιτυχίας. */
						perror("Failure to write the parking to the client.\n"); /* Εκτύπωση μηνύματος σφάλματος σε περίπτωση αποτυχίας αποστολής των στοιχείων. */
						exit(1); /* Έξοδος από το πρόγραμμα. */	
					}
					break; /* Έξοδος από τη δομή επιλογής switch για τις επιμέρους λειτουργίες. */
			}
		sem_close(my_sem); /* Κλείσιμο του σημαφόρου από την child process. */
		close(new_handle); /* Κλείσιμο του socket επικοινωνίας από την child process. */
		exit(0); /* Έξοδος από το πρόγραμμα. */	
		}		
	}
	kill(getppid(), SIGINT); /* Τερματισμός της parent process αν δοθεί σήμα, αλλά δεν πρόκειται να εκτελεστεί ποτέ. */		
}

void sig_chld(int sig_no){ /* Συνάρτηση για την εξουδετέρωση των zombie διεργασιών. */
       pid_t pid; /* Δήλωση μεταβλητών. */
       int stat;

       while((pid=waitpid(-1, &stat, WNOHANG))>0){ /* Βρόχος θανάτωσης διεργασιών child έπειτα από άμεση λήψη σήματος. */ 
              printf("The child process %d is now dead.\n", pid); /* Εκτύπωση μηνύματος θανάτωσης της child διεργασίας. */
       }
}

void kill_server(){ /* Συνάρτηση για τον τερματισμό του server. */
	close(sock_des); /* Κλείσιμο των socket επικοινωνίας. */
	close(new_handle);

	if(shmdt(count)==-1){ /* Αποδέσμευση της κοινής μνήμης και μερικός έλεγχος για την επιτυχία της προσπάθειας. */
  	 	printf("The shared memory could not be detached.\n"); /* Εκτύπωση μηνύματος αποτυχίας αποδέσμευσης της κοινής μνήμης. */
   		exit(1); /* Έξοδος από το πρόγραμμα. */
	}

	shmctl(shm_id, IPC_RMID, NULL); /* Διαγραφή της κοινής μνήμης. */
	sem_close(my_sem); /* Κλείσιμο του σημαφόρου. */
	sem_unlink(SEM_NAME); /* Διαγραφή του σημαφόρου. */
	printf("\nThe server was terminated.\n"); /* Εκτύπωση μηνύματος τερματισμού του server. */
	exit(0); /* Έξοδος από το πρόγραμμα. */
}
